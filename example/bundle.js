/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./example/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./bin/ScrollBarView.js":
/*!******************************!*\
  !*** ./bin/ScrollBarView.js ***!
  \******************************/
/*! exports provided: ScrollBarView, ScrollBarViewInitOption */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollBarView\", function() { return ScrollBarView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollBarViewInitOption\", function() { return ScrollBarViewInitOption; });\n/* harmony import */ var _SliderEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SliderEvent */ \"./bin/SliderEvent.js\");\n/* harmony import */ var _SliderView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SliderView */ \"./bin/SliderView.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n/**\n * スクロールバーを表すクラスです。\n *\n * このクラスは、スライダーに以下の機能を追加したものです。\n *\n * \t\t1.コンテンツサイズに合わせた、スクロールバーの伸縮\n * \t\t2.スクロールバーの伸縮にあわせた、移動範囲の制限\n * \t\t3.スクロールバーの伸縮にあわせた、移動値の取得\n *\n * 初期設定の注意\n * \t\t スクロール対象とマスクは同一の親をもつこと。\n * \t\t ローカル、グローバルの座標変換は行っていないので別の親をもつとスクロールが破たんします。\n */\n\nvar ScrollBarView =\n/*#__PURE__*/\nfunction (_SliderView) {\n  _inherits(ScrollBarView, _SliderView);\n\n  function ScrollBarView(option, scrollOption) {\n    var _this;\n\n    _classCallCheck(this, ScrollBarView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollBarView).call(this, option));\n    _this.autoHide = false;\n    /**\n     * スライダーイベントに応じてコンテンツをスクロールする\n     * @param {Object} e\n     */\n\n    _this.updateContentsPosition = function (e) {\n      var evt = e;\n\n      _this.updateContentsPositionWithRate(evt.rate);\n    };\n\n    ScrollBarViewInitOption.check(scrollOption);\n\n    _this.setTargetContents(scrollOption.targetContents);\n\n    _this.setContentsMask(scrollOption.contentsMask);\n\n    _this.changeRate(option.rate);\n\n    return _this;\n  }\n  /**\n   * 初期化処理\n   * @param {SliderViewInitOption} option\n   */\n\n\n  _createClass(ScrollBarView, [{\n    key: \"init\",\n    value: function init(option) {\n      _get(_getPrototypeOf(ScrollBarView.prototype), \"init\", this).call(this, option);\n\n      this.initSliderButtonSize();\n    }\n    /**\n     * スライダーボタンの位置を制限する関数\n     * @return 制限で切り落とされたスライダーボタンの座標値\n     */\n\n  }, {\n    key: \"limitSliderButtonPosition\",\n    value: function limitSliderButtonPosition(evt) {\n      var mousePos = this.getMousePosition(this, evt);\n      var sliderSize = this.slideButtonSize;\n      mousePos = Math.min(this._maxPosition - sliderSize / 2, mousePos);\n      mousePos = Math.max(this._minPosition + sliderSize / 2, mousePos);\n      return mousePos;\n    } ///////////////////////////\n    //\tピクセル位置 <-> 割合の相互変換\n    ///////////////////////////\n\n    /**\n     * スライダーの割合から、スライダーの位置を取得する\n     * @param\trate\n     * @return\n     */\n\n  }, {\n    key: \"changeRateToPixcel\",\n    value: function changeRateToPixcel(rate) {\n      var buttonSize = this.slideButtonSize;\n      var currentMax = this._maxPosition - buttonSize / 2;\n      var currentMin = this._minPosition + buttonSize / 2;\n      var currentPix = (currentMax - currentMin) * rate / _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"].MAX_RATE + currentMin;\n      currentPix = Math.max(currentPix, currentMin);\n      currentPix = Math.min(currentPix, currentMax);\n      return currentPix;\n    }\n    /**\n     * スライダーの座標から、スライダーの割合を取得する\n     * @param\tpixel\n     * @return\n     */\n\n  }, {\n    key: \"changePixexToRate\",\n    value: function changePixexToRate(pixel) {\n      var buttonSize = this.slideButtonSize;\n      var currentMax = this._maxPosition - buttonSize / 2;\n      var currentMin = this._minPosition + buttonSize / 2;\n      var currentRate = (pixel - currentMin) / (currentMax - currentMin) * _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"].MAX_RATE;\n      currentRate = Math.max(currentRate, 0.0);\n      currentRate = Math.min(currentRate, _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"].MAX_RATE);\n      return currentRate;\n    } ///////////////////////////\n    //\tスライドバーのサイズ更新\n    ///////////////////////////\n\n  }, {\n    key: \"initSliderButtonSize\",\n\n    /**\n     * スクロールバーのボタンサイズ及び位置を更新する。\n     * コンテンツサイズが変更された場合の更新にも利用する。\n     */\n    value: function initSliderButtonSize() {\n      if (!this._slideButton || !this._targetContents || !this._contentsMask) {\n        return;\n      }\n\n      this.updateSlideButtonSize();\n      this.initSliderPosition();\n      if (this.hasEventListener(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE)) return;\n      this.addEventListener(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE, this.updateContentsPosition);\n    }\n  }, {\n    key: \"initSliderPosition\",\n    value: function initSliderPosition() {\n      var zeroPos = this.getPosition(this._contentsMask);\n      var contentsPos = this.getPosition(this._targetContents);\n      var posDif = zeroPos - contentsPos;\n      var sizeDif = this.getSize(this._targetContents) - this.getSize(this._contentsMask);\n      this.changeRate(posDif / sizeDif * _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"].MAX_RATE);\n    }\n  }, {\n    key: \"updateSlideButtonSize\",\n    value: function updateSlideButtonSize() {\n      if (!this._targetContents || !this._contentsMask || !this._slideButton) {\n        return;\n      }\n\n      var fullSize = this._maxPosition - this._minPosition;\n      var contentsSize = this.getSize(this._targetContents);\n      var maskSize = this.getSize(this._contentsMask);\n      var sliderSize = fullSize * maskSize / contentsSize;\n\n      if (sliderSize > fullSize) {\n        sliderSize = fullSize;\n      }\n\n      this.setSize(this._slideButton, sliderSize); //autoHideの条件に一致するかを判定し、表示を切り替える。\n\n      this._slideButton.visible = this._slideButton.mouseEnabled = !this.isHide; // buttonMode = useHandCursor = !isHide;\n      // _slideButton.buttonMode = this._slideButton.useHandCursor = !isHide;\n    }\n    /**\n     * autoHideの条件に一致するかを判定する\n     */\n\n  }, {\n    key: \"updateContentsPositionWithRate\",\n\n    /**\n     * rate値を元にコンテンツをスクロールする。\n     * @param {number} rate\n     */\n    value: function updateContentsPositionWithRate(rate) {\n      var zeroPos = this.getPosition(this._contentsMask);\n      var nextPos = zeroPos - rate / _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"].MAX_RATE * (this.getSize(this._targetContents) - this.getSize(this._contentsMask));\n      this.setPosition(this._targetContents, nextPos);\n    }\n  }, {\n    key: \"onPressBaseFunction\",\n    value: function onPressBaseFunction(evt) {\n      if (this.isHide) return;\n\n      _get(_getPrototypeOf(ScrollBarView.prototype), \"onPressBaseFunction\", this).call(this, evt);\n    } ///////////////////////////\n    //\tgetter / setter\n    ///////////////////////////\n\n  }, {\n    key: \"setTargetContents\",\n    value: function setTargetContents(value) {\n      this._targetContents = value;\n      this.initSliderButtonSize();\n    }\n  }, {\n    key: \"setContentsMask\",\n    value: function setContentsMask(value) {\n      this._contentsMask = value;\n      this.initSliderButtonSize();\n    }\n  }, {\n    key: \"onDisposeFunction\",\n    value: function onDisposeFunction(e) {\n      this.removeEventListener(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE, this.updateContentsPosition);\n      this._targetContents = null;\n      this._contentsMask = null;\n\n      _get(_getPrototypeOf(ScrollBarView.prototype), \"onDisposeFunction\", this).call(this, e);\n    }\n  }, {\n    key: \"slideButtonSize\",\n    get: function get() {\n      this.updateSlideButtonSize();\n      return this.getSize(this._slideButton);\n    }\n  }, {\n    key: \"isHide\",\n    get: function get() {\n      //autoHideが設定されていない場合は常に表示\n      if (!this.autoHide) return false;\n      var fullSize = this._maxPosition - this._minPosition;\n      var contentsSize = this.getSize(this._targetContents);\n      var maskSize = this.getSize(this._contentsMask); //マスク、コンテンツ、スクロール幅のいずれかが0以下の場合スライダーを隠す\n\n      if (contentsSize < 0 || maskSize < 0 || fullSize < 0) {\n        return true;\n      } //マスクサイズとコンテンツサイズが同一の場合スライダーを隠す\n\n\n      return this.getSize(this._slideButton) == fullSize;\n    }\n  }, {\n    key: \"targetContents\",\n    get: function get() {\n      return this._targetContents;\n    }\n  }, {\n    key: \"contentsMask\",\n    get: function get() {\n      return this._contentsMask;\n    }\n  }]);\n\n  return ScrollBarView;\n}(_SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"]);\n/**\n * スクロールバーの初期化時に必須となる項目をまとめたオブジェクト\n * スクロール対象とスクロールエリアのマスクを指定する。\n */\n\nvar ScrollBarViewInitOption =\n/*#__PURE__*/\nfunction () {\n  function ScrollBarViewInitOption() {\n    _classCallCheck(this, ScrollBarViewInitOption);\n  }\n\n  _createClass(ScrollBarViewInitOption, null, [{\n    key: \"check\",\n    value: function check(option) {\n      if (option.contentsMask.parent != option.contentsMask.parent) {\n        console.warn(\"ScrollBarView : スクロールするコンテンツと、そのマスクは同一の親を持っている必要があります。\", option.targetContents, option.contentsMask);\n      }\n    }\n  }]);\n\n  return ScrollBarViewInitOption;\n}();\n\n//# sourceURL=webpack:///./bin/ScrollBarView.js?");

/***/ }),

/***/ "./bin/SliderEvent.js":
/*!****************************!*\
  !*** ./bin/SliderEvent.js ***!
  \****************************/
/*! exports provided: SliderEvent, SliderEventType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderEvent\", function() { return SliderEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderEventType\", function() { return SliderEventType; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * スライダーが移動した際に発行されるイベントです。\n * 現状のスライダー位置を報告します。\n */\nvar SliderEvent =\n/*#__PURE__*/\nfunction (_createjs$Event) {\n  _inherits(SliderEvent, _createjs$Event);\n\n  function SliderEvent(type) {\n    var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, SliderEvent);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SliderEvent).call(this, type, bubbles, cancelable));\n  }\n\n  _createClass(SliderEvent, [{\n    key: \"clone\",\n    value: function clone() {\n      var evt = new SliderEvent(this.type, this.bubbles, this.cancelable);\n      evt.rate = this.rate;\n      return evt;\n    }\n  }]);\n\n  return SliderEvent;\n}(createjs.Event);\nvar SliderEventType;\n\n(function (SliderEventType) {\n  SliderEventType[\"CHANGE\"] = \"event_slider_change\";\n  SliderEventType[\"CHANGE_FINISH\"] = \"event_slider_change_finish\";\n})(SliderEventType || (SliderEventType = {}));\n\n//# sourceURL=webpack:///./bin/SliderEvent.js?");

/***/ }),

/***/ "./bin/SliderView.js":
/*!***************************!*\
  !*** ./bin/SliderView.js ***!
  \***************************/
/*! exports provided: SliderView, SliderViewInitOption */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderView\", function() { return SliderView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderViewInitOption\", function() { return SliderViewInitOption; });\n/* harmony import */ var _SliderEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SliderEvent */ \"./bin/SliderEvent.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Container = createjs.Container;\nvar Point = createjs.Point;\n\n/**\n * スライダー用クラスです\n *\n * 使用上の注意\n *\n * オブジェクトのサイズの計測にgetBounds関数を使用しています。\n * shapeおよびContainerクラスでは、getBoundsの自動計測が効かない場合があるため\n * setBounds関数でサイズをあらかじめ与えてください。\n */\n\nvar SliderView =\n/*#__PURE__*/\nfunction (_Container) {\n  _inherits(SliderView, _Container);\n\n  /**\n   * コンストラクタ\n   * @param {SliderViewInitOption} option\n   */\n  function SliderView(option) {\n    var _this;\n\n    _classCallCheck(this, SliderView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SliderView).call(this));\n    _this.dragStartPos = new createjs.Point();\n    _this.isDragging = false; // 現在スライド中か否か\n\n    _this.isHorizontal = true;\n    _this.isReverse = false;\n    /**\n     * スライダーのドラッグを開始する\n     * @param\tevt\n     */\n\n    _this.startMove = function (e) {\n      var evt = e;\n      _this.isDragging = true;\n      var target = evt.currentTarget;\n\n      var localPos = _this.globalToLocal(evt.stageX, evt.stageY);\n\n      _this.dragStartPos = new Point(localPos.x - target.x, localPos.y - target.y);\n\n      _this.stage.addEventListener(\"pressmove\", _this.moveSlider);\n\n      _this.stage.addEventListener(\"pressup\", _this.moveSliderFinish);\n    };\n    /**\n     * スライダーのドラッグ中の処理\n     * @param\tevt\n     */\n\n\n    _this.moveSlider = function (e) {\n      var evt = e; //現在のスライダー位置を算出\n\n      var mousePos = _this.limitSliderButtonPosition(evt); //各MCの位置、幅を調整\n\n\n      _this.updateParts(mousePos); //レートに反映\n\n\n      _this._rate = _this.changePixexToRate(mousePos); //イベントを発行\n\n      _this.dispathSliderEvent(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE);\n    };\n    /**\n     * スライダーのドラッグ終了時の処理\n     * @param\tevt\n     */\n\n\n    _this.moveSliderFinish = function (e) {\n      var evt = e;\n      _this.isDragging = false;\n\n      _this.stage.removeEventListener(\"pressmove\", _this.moveSlider);\n\n      _this.stage.removeEventListener(\"pressup\", _this.moveSliderFinish);\n\n      _this.dispathSliderEvent(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE_FINISH);\n    };\n    /**\n     * スライダーの地をクリックしたときの処理\n     * その位置までスライダーをジャンプする\n     * @param\tevt\n     */\n\n\n    _this.pressBase = function (evt) {\n      _this.onPressBaseFunction(evt);\n    };\n    /**\n     * オブジェクトの廃棄処理\n     * @param\te\n     */\n\n\n    _this.dispose = function (e) {\n      _this.onDisposeFunction(e);\n    };\n\n    _this.addEventListener(\"removed\", _this.dispose);\n\n    _this.init(option);\n\n    return _this;\n  }\n  /**\n   * 初期化処理\n   */\n\n\n  _createClass(SliderView, [{\n    key: \"init\",\n    value: function init(option) {\n      option = SliderViewInitOption.init(option);\n      this.bar = option.bar;\n      this.slideButton = option.button;\n      this.barMask = option.mask;\n      this.base = option.base;\n      this._minPosition = option.minPosition;\n      this._maxPosition = option.maxPosition;\n      this.isHorizontal = option.isHorizontal;\n      this.isReverse = option.isReverse;\n      this._rate = option.rate;\n      this.swapBaseChildren();\n      this.changeRate(this._rate);\n    }\n    /**\n     * パーツの重なり順を適正化する。\n     */\n\n  }, {\n    key: \"swapBaseChildren\",\n    value: function swapBaseChildren() {\n      this.addChildMe(this._base);\n      this.addChildMe(this._bar);\n      this.addChildMe(this._slideButton);\n    }\n  }, {\n    key: \"addChildMe\",\n    value: function addChildMe(obj) {\n      if (obj) {\n        if (obj.parent) obj.parent.removeChild(obj);\n        this.addChild(obj);\n      }\n    }\n    /**\n     * スライダーの位置を変更する\n     * @param\trate\tスライダーの位置 MIN 0.0 ~ MAX 100.0\n     */\n\n  }, {\n    key: \"changeRate\",\n    value: function changeRate(rate) {\n      if (this.isDragging) return;\n      if (!this.isReverse) this._rate = rate;else this._rate = SliderView.MAX_RATE - rate;\n      this.updateSliderPositions(); //イベントを発行\n\n      this.dispathSliderEvent(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE);\n    }\n    /**\n     * スライダーの位置を調整する。\n     * changeRate関数の内部関数\n     */\n\n  }, {\n    key: \"updateSliderPositions\",\n    value: function updateSliderPositions() {\n      var pos = this.changeRateToPixcel(this._rate); //各MCの位置、幅を調整\n\n      this.updateParts(pos);\n    }\n    /**\n     * スライダーボタンの位置を制限する関数\n     * @return 制限で切り落とされたスライダーボタンの座標値\n     */\n\n  }, {\n    key: \"limitSliderButtonPosition\",\n    value: function limitSliderButtonPosition(evt) {\n      var mousePos = this.getMousePosition(this, evt);\n      mousePos = this._maxPosition < mousePos ? this._maxPosition : mousePos;\n      /*Math.min( _maxPosition, mousePos );*/\n\n      mousePos = this._minPosition > mousePos ? this._minPosition : mousePos;\n      /*Math.max( _minPosition, mousePos );*/\n\n      return mousePos;\n    }\n    /**\n     * 各MCの位置、サイズをマウスポインタの位置に合わせて更新する\n     * moveSliderの内部処理\n     * @param\tmousePos\n     */\n\n  }, {\n    key: \"updateParts\",\n    value: function updateParts(mousePos) {\n      if (this._bar && !this._barMask) this.setSize(this._bar, Math.max(2.0, mousePos - this._minPosition));\n\n      if (this._barMask) {\n        if (!this.isReverse) this.setSize(this._barMask, mousePos - this.getPosition(this._barMask));else this.setSize(this._barMask, this.getPosition(this._barMask) - mousePos);\n      }\n\n      if (this._slideButton) this.setPosition(this._slideButton, mousePos);\n    }\n    /**\n     * スライダーの変更に関するイベントを発行する\n     * @param\ttype\n     */\n\n  }, {\n    key: \"dispathSliderEvent\",\n    value: function dispathSliderEvent(type) {\n      var sliderEvent = new _SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEvent\"](type);\n      var currentRate = this._rate;\n      if (this.isReverse) currentRate = SliderView.MAX_RATE - this._rate;\n      sliderEvent.rate = currentRate;\n      this.dispatchEvent(sliderEvent);\n    }\n  }, {\n    key: \"onPressBaseFunction\",\n    value: function onPressBaseFunction(evt) {\n      this.dragStartPos = new Point();\n      this.moveSlider(evt);\n      this.dispathSliderEvent(_SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE_FINISH);\n    }\n    /**\n     * スライダーの割合から、スライダーの位置を取得する\n     * @param\trate\n     * @return\n     */\n\n  }, {\n    key: \"changeRateToPixcel\",\n    value: function changeRateToPixcel(rate) {\n      var currentPix = (this._maxPosition - this._minPosition) * rate / SliderView.MAX_RATE + this._minPosition;\n      currentPix = currentPix > this._minPosition ? currentPix : this._minPosition;\n      /*Math.max( currentPix, _minPosition );*/\n\n      currentPix = currentPix < this._maxPosition ? currentPix : this._maxPosition;\n      /*Math.min( currentPix, _maxPosition );*/\n\n      return currentPix;\n    }\n    /**\n     * スライダーのX座標から、スライダーの割合を取得する\n     * @param\tpixel\n     * @return\n     */\n\n  }, {\n    key: \"changePixexToRate\",\n    value: function changePixexToRate(pixel) {\n      var currentRate = (pixel - this._minPosition) / (this._maxPosition - this._minPosition) * SliderView.MAX_RATE;\n      currentRate = currentRate > 0.0 ? currentRate : 0.0;\n      /*Math.max( currentRate, 0.0 );*/\n\n      currentRate = currentRate < SliderView.MAX_RATE ? currentRate : SliderView.MAX_RATE;\n      /*Math.min( currentRate, SliderView.MAX_RATE );*/\n\n      return currentRate;\n    }\n    /**\n     * ディスプレイオブジェクトからスクロール方向の座標値を取り出す\n     * @param\tdisplayObj\n     * @return\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(displayObj) {\n      if (this.isHorizontal) {\n        return displayObj.x;\n      } else {\n        return displayObj.y;\n      }\n    }\n    /**\n     * ディスプレイオブジェクトにスクロール方向の座標地を設定する\n     * @param\tdisplayObj\n     * @param\tposition\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(displayObj, position) {\n      if (this.isHorizontal) {\n        displayObj.x = position;\n      } else {\n        displayObj.y = position;\n      }\n    }\n    /**\n     * スクロール方向のマウス座標を取得する\n     * limitSliderButtonPosition内の処理\n     * @param\tdisplayObj\n     * @return\n     */\n\n  }, {\n    key: \"getMousePosition\",\n    value: function getMousePosition(displayObj, evt) {\n      var localPos = displayObj.globalToLocal(evt.stageX, evt.stageY);\n\n      if (this.isHorizontal) {\n        return localPos.x - this.dragStartPos.x;\n      } else {\n        return localPos.y - this.dragStartPos.y;\n      }\n    }\n    /**\n     * スクロール方向の高さ、もしくは幅を取得する\n     * @param\tdisplayObj\n     * @return\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize(displayObj) {\n      var size = displayObj.getBounds();\n\n      if (this.isHorizontal) {\n        return size.width * displayObj.scaleX;\n      } else {\n        return size.height * displayObj.scaleY;\n      }\n    }\n    /**\n     * スクロール方向の高さ、もしくは幅を設定する\n     * @param\tdisplayObj\n     * @return\n     */\n\n  }, {\n    key: \"setSize\",\n    value: function setSize(displayObj, amount) {\n      var size = displayObj.getBounds();\n\n      if (this.isHorizontal) {\n        displayObj.scaleX = amount / size.width;\n      } else {\n        displayObj.scaleY = amount / size.height;\n      }\n    } ///////////////////////////\n    //\tgetter / setter\n    ///////////////////////////\n\n  }, {\n    key: \"onDisposeFunction\",\n    value: function onDisposeFunction(e) {\n      this.removeEventListener(\"removed\", this.dispose);\n\n      this._base.removeEventListener(\"click\", this.pressBase);\n\n      this._slideButton.removeEventListener(\"mousedown\", this.startMove);\n\n      this._base = null;\n      this._bar = null;\n      this._barMask = null;\n      this._slideButton = null;\n    }\n  }, {\n    key: \"base\",\n    set: function set(value) {\n      if (!value) return;\n      this._base = value;\n      this._base.mouseEnabled = true;\n\n      this._base.addEventListener(\"click\", this.pressBase);\n\n      this.addChildMe(value);\n    },\n    get: function get() {\n      return this._base;\n    }\n  }, {\n    key: \"bar\",\n    set: function set(value) {\n      if (!value) return;\n      this._bar = value;\n      if (this._barMask) this._bar.mask = this._barMask;\n      this._bar.mouseEnabled = false; // this._bar.mouseChildren = false;\n\n      this.addChildMe(value);\n    }\n  }, {\n    key: \"slideButton\",\n    set: function set(value) {\n      if (!value) return;\n      this._slideButton = value;\n\n      this._slideButton.addEventListener(\"mousedown\", this.startMove);\n\n      this.addChildMe(value);\n    }\n  }, {\n    key: \"barMask\",\n    set: function set(value) {\n      if (!value) return;\n      this._barMask = value;\n      if (this._bar) this._bar.mask = this._barMask;\n      this._barMask.mouseEnabled = false;\n      this.addChildMe(value);\n    }\n  }, {\n    key: \"minPosition\",\n    set: function set(value) {\n      this._minPosition = value;\n    }\n  }, {\n    key: \"maxPosition\",\n    set: function set(value) {\n      this._maxPosition = value;\n    }\n  }, {\n    key: \"rate\",\n    get: function get() {\n      return this._rate;\n    }\n  }]);\n\n  return SliderView;\n}(Container);\nSliderView.MAX_RATE = 100.0;\n/**\n * スライダーを初期化する際のオプション\n */\n\nvar SliderViewInitOption =\n/*#__PURE__*/\nfunction () {\n  function SliderViewInitOption() {\n    _classCallCheck(this, SliderViewInitOption);\n  }\n\n  _createClass(SliderViewInitOption, null, [{\n    key: \"init\",\n    value: function init(option) {\n      if (option.rate == null) {\n        option.rate = 0.0;\n      }\n\n      if (option.isHorizontal == null) {\n        option.isHorizontal = true;\n      }\n\n      if (option.isReverse == null) {\n        option.isReverse = false;\n      }\n\n      this.check(option);\n      return option;\n    }\n  }, {\n    key: \"check\",\n    value: function check(option) {\n      var checkBounds = function checkBounds(displayObject) {\n        if (displayObject) {\n          if (displayObject.getBounds() === null) {\n            throw new Error(\"初期化オプションで指定されたShapeにバウンディングボックスが存在しません。Shapeを利用する場合はsetBounds関数を利用してバウンディングボックスを手動で設定してください。\");\n          }\n\n          if (displayObject.parent) {\n            console.warn(\"初期化オプションで指定されたパーツがすでに別の親にaddChildされています。SliderViewおよびScrollBarViewの構成パーツはインスタンスにaddChildされることを前提としています。\");\n          }\n        }\n      };\n\n      checkBounds(option.base);\n      checkBounds(option.button);\n      checkBounds(option.mask);\n      checkBounds(option.bar);\n    }\n  }]);\n\n  return SliderViewInitOption;\n}();\n\n//# sourceURL=webpack:///./bin/SliderView.js?");

/***/ }),

/***/ "./bin/index.js":
/*!**********************!*\
  !*** ./bin/index.js ***!
  \**********************/
/*! exports provided: SliderEvent, SliderEventType, SliderView, SliderViewInitOption, ScrollBarView, ScrollBarViewInitOption */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SliderEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SliderEvent */ \"./bin/SliderEvent.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SliderEvent\", function() { return _SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SliderEventType\", function() { return _SliderEvent__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"]; });\n\n/* harmony import */ var _SliderView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SliderView */ \"./bin/SliderView.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SliderView\", function() { return _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SliderViewInitOption\", function() { return _SliderView__WEBPACK_IMPORTED_MODULE_1__[\"SliderViewInitOption\"]; });\n\n/* harmony import */ var _ScrollBarView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScrollBarView */ \"./bin/ScrollBarView.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScrollBarView\", function() { return _ScrollBarView__WEBPACK_IMPORTED_MODULE_2__[\"ScrollBarView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ScrollBarViewInitOption\", function() { return _ScrollBarView__WEBPACK_IMPORTED_MODULE_2__[\"ScrollBarViewInitOption\"]; });\n\n\n\n\n\n//# sourceURL=webpack:///./bin/index.js?");

/***/ }),

/***/ "./example/main.js":
/*!*************************!*\
  !*** ./example/main.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bin_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bin/index.js */ \"./bin/index.js\");\n\n\n\n\nvar onDomContentsLoaded = function onDomContentsLoaded() {\n  //FPSメーターの生成と配置\n  var stats = new Stats();\n  stats.showPanel(0);\n  stats.domElement.style.cssText = \"position:absolute; z-index:999; top:0; left:0;\";\n  document.body.appendChild(stats.domElement); //ステージ更新処理\n\n  var updateStage = function updateStage() {\n    stats.begin();\n    stage.update();\n    stats.end();\n  }; //stageの初期化\n\n\n  var canvas = document.getElementById(\"appCanvas\");\n  var stage = new createjs.Stage(canvas);\n  createjs.Ticker.on(\"tick\", updateStage);\n  initSlider(stage);\n  initScrollBar(stage);\n};\n/**\n * スライダーの実装サンプル\n * @param stage\n */\n\n\nvar initSlider = function initSlider(stage) {\n  var SLIDER_W = 200;\n  var SLIDER_H = 64;\n\n  var getSliderBase = function getSliderBase(color) {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(color);\n    g.moveTo(0, 0).lineTo(SLIDER_W, 0).lineTo(SLIDER_W, SLIDER_H).lineTo(0, 0).endFill();\n    shape.setBounds(0, 0, SLIDER_W, SLIDER_H);\n    return shape;\n  };\n\n  var getSliderMask = function getSliderMask() {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(\"rgba( 255, 0, 255, 0.0)\");\n    g.drawRect(0, 0, SLIDER_W, SLIDER_H);\n    shape.setBounds(0, 0, SLIDER_W, SLIDER_H);\n    return shape;\n  };\n\n  var getButton = function getButton(color) {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(color);\n    g.drawRect(-8, 0, 16, SLIDER_H);\n    shape.setBounds(-8, 0, 16, SLIDER_H);\n    return shape;\n  };\n\n  var slider = new _bin_index_js__WEBPACK_IMPORTED_MODULE_0__[\"SliderView\"]({\n    base: getSliderBase(\"#00f\"),\n    bar: getSliderBase(\"#0ff\"),\n    button: getButton(\"rgba( 255, 255, 0, 0.5)\"),\n    mask: getSliderMask(),\n    minPosition: 0,\n    maxPosition: SLIDER_W,\n    rate: 50.0\n  });\n  slider.addEventListener(_bin_index_js__WEBPACK_IMPORTED_MODULE_0__[\"SliderEventType\"].CHANGE, function (e) {\n    console.log(e.rate);\n  });\n  stage.addChild(slider);\n  slider.x = 200;\n  slider.y = 200;\n};\n\nvar initScrollBar = function initScrollBar(container) {\n  var SCROLLBAR_W = 16;\n  var SCROLLBAR_H = 360;\n  var SCROLLBAR_Y = 120;\n\n  var getBase = function getBase(color) {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(color);\n    g.drawRect(0, 0, SCROLLBAR_W, SCROLLBAR_H);\n    shape.setBounds(0, 0, SCROLLBAR_W, SCROLLBAR_H);\n    return shape;\n  };\n\n  var getButton = function getButton(color) {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(color);\n    g.drawRect(-SCROLLBAR_W / 2, -SCROLLBAR_W / 2, SCROLLBAR_W, SCROLLBAR_W);\n    shape.setBounds(-SCROLLBAR_W / 2, -SCROLLBAR_W / 2, SCROLLBAR_W, SCROLLBAR_W);\n    shape.x = SCROLLBAR_W / 2;\n    return shape;\n  };\n\n  var scrollContents = new createjs.Container();\n  container.addChild(scrollContents);\n  scrollContents.x = 800;\n  scrollContents.y = SCROLLBAR_Y;\n  var contentsW = 240;\n  var contentsH = SCROLLBAR_H;\n\n  var getContents = function getContents(color, height) {\n    var shape = new createjs.Shape();\n    var g = shape.graphics;\n    g.beginFill(color);\n    g.drawRect(0, 0, contentsW, height);\n    shape.setBounds(0, 0, contentsW, height);\n    scrollContents.addChild(shape);\n    return shape;\n  };\n\n  var barOption = {\n    targetContents: getContents(\"#f0f\", contentsH * 2),\n    contentsMask: getContents(\"rgba(0,0,255,0.3)\", contentsH)\n  };\n  var scrollbar = new _bin_index_js__WEBPACK_IMPORTED_MODULE_0__[\"ScrollBarView\"]({\n    base: getBase(\"#00f\"),\n    button: getButton(\"#ff0\"),\n    minPosition: 0,\n    maxPosition: SCROLLBAR_H,\n    rate: 30.0,\n    isHorizontal: false\n  }, barOption);\n  container.addChild(scrollbar);\n  scrollbar.x = scrollContents.x + contentsW;\n  scrollbar.y = SCROLLBAR_Y;\n};\n/**\n * DOMContentLoaded以降に初期化処理を実行する\n */\n\n\nif (document.readyState !== \"loading\") {\n  onDomContentsLoaded();\n} else {\n  document.addEventListener(\"DOMContentLoaded\", onDomContentsLoaded);\n}\n\n//# sourceURL=webpack:///./example/main.js?");

/***/ })

/******/ });